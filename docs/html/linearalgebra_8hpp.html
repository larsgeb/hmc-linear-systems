<!-- HTML header for doxygen 1.8.8-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <!-- For Mobile Devices -->
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
        <meta name="generator" content="Doxygen 1.8.13"/>
        <script type="text/javascript" src="https://code.jquery.com/jquery-2.1.1.min.js"></script>
        <title>Hamiltonian Monte Carlo: linearalgebra.hpp File Reference</title>
        <!--<link href="tabs.css" rel="stylesheet" type="text/css"/>-->
        <script type="text/javascript" src="dynsections.js"></script>
        <link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
        <script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
        <link href="doxygen.css" rel="stylesheet" type="text/css" />
        <link href="customdoxygen.css" rel="stylesheet" type="text/css"/>
        <link href='https://fonts.googleapis.com/css?family=Roboto+Slab' rel='stylesheet' type='text/css'>
        <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.1/css/bootstrap.min.css">
        <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.1/js/bootstrap.min.js"></script>
        <script type="text/javascript" src="doxy-boot.js"></script>
    </head>
    <body>
        <nav class="navbar navbar-default" role="navigation">
            <div class="container">
                <div class="navbar-header">
                    <a class="navbar-brand" href="https://larsgeb.github.io"><b>Lars Gebraad</b></a><a class="navbar-brand">- Hamiltonian Monte Carlo </a>
                </div>
            </div>
        </nav>
        <div id="top"><!-- do not remove this div, it is closed by doxygen! -->
            <div class="content" id="content">
                <div class="container">
                    <div class="row">
                        <div class="col-sm-12 panel " style="padding-bottom: 15px;">
                            <div style="margin-bottom: 15px;">
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">linearalgebra.hpp File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Linear algebra functions operating on standard library containers.  
<a href="#details">More...</a></p>
<div class="textblock"><div class="dynheader">
This graph shows which files directly or indirectly include this file:</div>
<div class="dyncontent">
<div class="center"><img src="linearalgebra_8hpp__dep__incl.png" border="0" usemap="#linearalgebra_8hppdep" alt=""/></div>
<map name="linearalgebra_8hppdep" id="linearalgebra_8hppdep">
<area shape="rect" id="node2" href="auxiliary_8cpp.html" title="auxiliary.cpp" alt="" coords="5,80,100,107"/>
<area shape="rect" id="node3" href="montecarlo_8cpp.html" title="montecarlo.cpp" alt="" coords="124,80,235,107"/>
<area shape="rect" id="node4" href="randomnumbers_8cpp.html" title="randomnumbers.cpp" alt="" coords="259,80,399,107"/>
<area shape="rect" id="node5" href="testMultivariate_8cpp.html" title="testMultivariate.cpp" alt="" coords="423,80,559,107"/>
</map>
</div>
</div>
<p><a href="linearalgebra_8hpp_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a2c0f436b85983ff2f83d8baca22e76e8"><td class="memItemLeft" align="right" valign="top">std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="linearalgebra_8hpp.html#a2c0f436b85983ff2f83d8baca22e76e8">MatrixVectorProduct</a> (std::vector&lt; std::vector&lt; double &gt;&gt; M, std::vector&lt; double &gt; A)</td></tr>
<tr class="memdesc:a2c0f436b85983ff2f83d8baca22e76e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function incorporating the standard matrix-vector product. The result is a column vector.  <a href="#a2c0f436b85983ff2f83d8baca22e76e8">More...</a><br /></td></tr>
<tr class="separator:a2c0f436b85983ff2f83d8baca22e76e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0972fd0613212a5f363f740fa8da87b"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::vector&lt; double &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="linearalgebra_8hpp.html#ad0972fd0613212a5f363f740fa8da87b">MatrixMatrixProduct</a> (std::vector&lt; std::vector&lt; double &gt;&gt; M, std::vector&lt; std::vector&lt; double &gt;&gt; N)</td></tr>
<tr class="memdesc:ad0972fd0613212a5f363f740fa8da87b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function incorporating the standard matrix-matrix product, producing a new matrix. Matrix M should have as many columns as N has rows, otherwise an exception is thrown.  <a href="#ad0972fd0613212a5f363f740fa8da87b">More...</a><br /></td></tr>
<tr class="separator:ad0972fd0613212a5f363f740fa8da87b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22e3e11bc1914c1335383c9c22abaf88"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::vector&lt; double &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="linearalgebra_8hpp.html#a22e3e11bc1914c1335383c9c22abaf88">MatrixMatrixSum</a> (std::vector&lt; std::vector&lt; double &gt;&gt; M, std::vector&lt; std::vector&lt; double &gt;&gt; N)</td></tr>
<tr class="memdesc:a22e3e11bc1914c1335383c9c22abaf88"><td class="mdescLeft">&#160;</td><td class="mdescRight">A function to calculate the sum of the entries of two matrices.  <a href="#a22e3e11bc1914c1335383c9c22abaf88">More...</a><br /></td></tr>
<tr class="separator:a22e3e11bc1914c1335383c9c22abaf88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4d8fb25b53a9b6ab36eba4314e7874f"><td class="memItemLeft" align="right" valign="top">std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="linearalgebra_8hpp.html#af4d8fb25b53a9b6ab36eba4314e7874f">GetMatrixRow</a> (std::vector&lt; std::vector&lt; double &gt;&gt; M, int row)</td></tr>
<tr class="memdesc:af4d8fb25b53a9b6ab36eba4314e7874f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to get a row from a matrix.  <a href="#af4d8fb25b53a9b6ab36eba4314e7874f">More...</a><br /></td></tr>
<tr class="separator:af4d8fb25b53a9b6ab36eba4314e7874f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a127f5797dcb79c36454247e48e4e8c9e"><td class="memItemLeft" align="right" valign="top">std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="linearalgebra_8hpp.html#a127f5797dcb79c36454247e48e4e8c9e">GetMatrixColumn</a> (std::vector&lt; std::vector&lt; double &gt;&gt; M, int column)</td></tr>
<tr class="memdesc:a127f5797dcb79c36454247e48e4e8c9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to get a column from a matrix.  <a href="#a127f5797dcb79c36454247e48e4e8c9e">More...</a><br /></td></tr>
<tr class="separator:a127f5797dcb79c36454247e48e4e8c9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a31c1bd455fa18e0127d3a8160ddf98"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::vector&lt; double &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="linearalgebra_8hpp.html#a4a31c1bd455fa18e0127d3a8160ddf98">TransposeMatrix</a> (std::vector&lt; std::vector&lt; double &gt;&gt; M)</td></tr>
<tr class="memdesc:a4a31c1bd455fa18e0127d3a8160ddf98"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to transpose a matrix M of size i x j into a matrix N of size j x i, where \(M_{ij} = N_{ji}\).  <a href="#a4a31c1bd455fa18e0127d3a8160ddf98">More...</a><br /></td></tr>
<tr class="separator:a4a31c1bd455fa18e0127d3a8160ddf98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a451df8b9bf01cd6a09234161ecf39dd5"><td class="memItemLeft" align="right" valign="top">std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="linearalgebra_8hpp.html#a451df8b9bf01cd6a09234161ecf39dd5">MatrixTrace</a> (std::vector&lt; std::vector&lt; double &gt;&gt; M)</td></tr>
<tr class="memdesc:a451df8b9bf01cd6a09234161ecf39dd5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to the trace of a square \(n \times n\) matrix \(M\).  <a href="#a451df8b9bf01cd6a09234161ecf39dd5">More...</a><br /></td></tr>
<tr class="separator:a451df8b9bf01cd6a09234161ecf39dd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6ebca5acd83b99acfd9e48c1cceafb2"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::vector&lt; double &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="linearalgebra_8hpp.html#af6ebca5acd83b99acfd9e48c1cceafb2">InvertMatrixElements</a> (std::vector&lt; std::vector&lt; double &gt;&gt; M)</td></tr>
<tr class="memdesc:af6ebca5acd83b99acfd9e48c1cceafb2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to take the inverse of the individual matrix elements.  <a href="#af6ebca5acd83b99acfd9e48c1cceafb2">More...</a><br /></td></tr>
<tr class="separator:af6ebca5acd83b99acfd9e48c1cceafb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab572e4af238b6622d11655a0704cb918"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::vector&lt; double &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="linearalgebra_8hpp.html#ab572e4af238b6622d11655a0704cb918">VectorToDiagonal</a> (std::vector&lt; double &gt; A)</td></tr>
<tr class="memdesc:ab572e4af238b6622d11655a0704cb918"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function which takes a std::vector of double to make a diagonal matrix of it, such that \( A_{i} = M_{ii} \).  <a href="#ab572e4af238b6622d11655a0704cb918">More...</a><br /></td></tr>
<tr class="separator:ab572e4af238b6622d11655a0704cb918"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3815a35abdfaafef440a2bbb8c62a58f"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="linearalgebra_8hpp.html#a3815a35abdfaafef440a2bbb8c62a58f">VectorVectorProduct</a> (std::vector&lt; double &gt; A, std::vector&lt; double &gt; B)</td></tr>
<tr class="memdesc:a3815a35abdfaafef440a2bbb8c62a58f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dot product of vectors.  <a href="#a3815a35abdfaafef440a2bbb8c62a58f">More...</a><br /></td></tr>
<tr class="separator:a3815a35abdfaafef440a2bbb8c62a58f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a597e4b880c84d3ce0442b6afc04dceaf"><td class="memItemLeft" align="right" valign="top">std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="linearalgebra_8hpp.html#a597e4b880c84d3ce0442b6afc04dceaf">VectorDifference</a> (std::vector&lt; double &gt; A, std::vector&lt; double &gt; B)</td></tr>
<tr class="memdesc:a597e4b880c84d3ce0442b6afc04dceaf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector difference between two vectors.  <a href="#a597e4b880c84d3ce0442b6afc04dceaf">More...</a><br /></td></tr>
<tr class="separator:a597e4b880c84d3ce0442b6afc04dceaf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d9bdc7160e3c8640cf0eaca466985ee"><td class="memItemLeft" align="right" valign="top">std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="linearalgebra_8hpp.html#a6d9bdc7160e3c8640cf0eaca466985ee">VectorSum</a> (std::vector&lt; double &gt; A, std::vector&lt; double &gt; B)</td></tr>
<tr class="memdesc:a6d9bdc7160e3c8640cf0eaca466985ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector sum between two vectors.  <a href="#a6d9bdc7160e3c8640cf0eaca466985ee">More...</a><br /></td></tr>
<tr class="separator:a6d9bdc7160e3c8640cf0eaca466985ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9421c6d0ca55335d00acec320e0214b4"><td class="memItemLeft" align="right" valign="top">std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="linearalgebra_8hpp.html#a9421c6d0ca55335d00acec320e0214b4">VectorScalarProduct</a> (std::vector&lt; double &gt; A, double b)</td></tr>
<tr class="memdesc:a9421c6d0ca55335d00acec320e0214b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector scalar prodcut of vector and scalar.  <a href="#a9421c6d0ca55335d00acec320e0214b4">More...</a><br /></td></tr>
<tr class="separator:a9421c6d0ca55335d00acec320e0214b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4267f1b16fd7b2f26ec7505f6e978b9f"><td class="memItemLeft" align="right" valign="top">std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="linearalgebra_8hpp.html#a4267f1b16fd7b2f26ec7505f6e978b9f">NormalizeVector</a> (std::vector&lt; double &gt; A)</td></tr>
<tr class="memdesc:a4267f1b16fd7b2f26ec7505f6e978b9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Normalizes a vector to unit length.  <a href="#a4267f1b16fd7b2f26ec7505f6e978b9f">More...</a><br /></td></tr>
<tr class="separator:a4267f1b16fd7b2f26ec7505f6e978b9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8407d518eb711c46ddc3e729299fa011"><td class="memItemLeft" align="right" valign="top">std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="linearalgebra_8hpp.html#a8407d518eb711c46ddc3e729299fa011">SolveLowerTriangular</a> (std::vector&lt; std::vector&lt; double &gt;&gt; L, std::vector&lt; double &gt; x)</td></tr>
<tr class="memdesc:a8407d518eb711c46ddc3e729299fa011"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solve linear equation \( L y = x\) where \( L \) is a lower triangular \( n \times n\) matrix and \( x \) and \( y \) are \( n\) dimensional vectors. Uses forward and backward substitution to iteratively solve the system.  <a href="#a8407d518eb711c46ddc3e729299fa011">More...</a><br /></td></tr>
<tr class="separator:a8407d518eb711c46ddc3e729299fa011"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a992c16cae0e72fae2e70a6cd1dab03"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::vector&lt; double &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="linearalgebra_8hpp.html#a7a992c16cae0e72fae2e70a6cd1dab03">InvertLowerTriangular</a> (std::vector&lt; std::vector&lt; double &gt;&gt; L)</td></tr>
<tr class="memdesc:a7a992c16cae0e72fae2e70a6cd1dab03"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invert a lower triangular \( n \times n\) matrix by use of solving the system \( L L^{-1} = I\) per column of \( I \) using <a class="el" href="linearalgebra_8hpp.html#a8407d518eb711c46ddc3e729299fa011" title="Solve linear equation  where  is a lower triangular  matrix and  and  are  dimensional vectors...">SolveLowerTriangular()</a>, the identity matrix.  <a href="#a7a992c16cae0e72fae2e70a6cd1dab03">More...</a><br /></td></tr>
<tr class="separator:a7a992c16cae0e72fae2e70a6cd1dab03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2747a4af46ad421a36728cf645df6bbc"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::vector&lt; double &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="linearalgebra_8hpp.html#a2747a4af46ad421a36728cf645df6bbc">CholeskyDecompose</a> (std::vector&lt; std::vector&lt; double &gt;&gt; A)</td></tr>
<tr class="memdesc:a2747a4af46ad421a36728cf645df6bbc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cholesky-decomposition of a positive definite Hermitian \( n \times n\) matrix \( M \).  <a href="#a2747a4af46ad421a36728cf645df6bbc">More...</a><br /></td></tr>
<tr class="separator:a2747a4af46ad421a36728cf645df6bbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d49ea659488ef4b766b63011282bf5f"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::vector&lt; double &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="linearalgebra_8hpp.html#a1d49ea659488ef4b766b63011282bf5f">operator*</a> (std::vector&lt; std::vector&lt; double &gt;&gt; M, std::vector&lt; std::vector&lt; double &gt;&gt; N)</td></tr>
<tr class="memdesc:a1d49ea659488ef4b766b63011282bf5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Operator form of <a class="el" href="linearalgebra_8hpp.html#ad0972fd0613212a5f363f740fa8da87b" title="Function incorporating the standard matrix-matrix product, producing a new matrix. Matrix M should have as many columns as N has rows, otherwise an exception is thrown. ">MatrixMatrixProduct()</a>, using std library forwarding.  <a href="#a1d49ea659488ef4b766b63011282bf5f">More...</a><br /></td></tr>
<tr class="separator:a1d49ea659488ef4b766b63011282bf5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66df0c52ac36dd31ea31fb18ffbfeeb8"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="linearalgebra_8hpp.html#a66df0c52ac36dd31ea31fb18ffbfeeb8">operator*</a> (std::vector&lt; double &gt; A, std::vector&lt; double &gt; B)</td></tr>
<tr class="memdesc:a66df0c52ac36dd31ea31fb18ffbfeeb8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Operator form of <a class="el" href="linearalgebra_8hpp.html#a3815a35abdfaafef440a2bbb8c62a58f" title="Dot product of vectors. ">VectorVectorProduct()</a>, using std library forwarding.  <a href="#a66df0c52ac36dd31ea31fb18ffbfeeb8">More...</a><br /></td></tr>
<tr class="separator:a66df0c52ac36dd31ea31fb18ffbfeeb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3ed2d23c2944de6d892d771254fb1f1"><td class="memItemLeft" align="right" valign="top">std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="linearalgebra_8hpp.html#aa3ed2d23c2944de6d892d771254fb1f1">operator*</a> (std::vector&lt; std::vector&lt; double &gt;&gt; M, std::vector&lt; double &gt; A)</td></tr>
<tr class="memdesc:aa3ed2d23c2944de6d892d771254fb1f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Operator form of <a class="el" href="linearalgebra_8hpp.html#a2c0f436b85983ff2f83d8baca22e76e8" title="Function incorporating the standard matrix-vector product. The result is a column vector...">MatrixVectorProduct()</a>, using std library forwarding.  <a href="#aa3ed2d23c2944de6d892d771254fb1f1">More...</a><br /></td></tr>
<tr class="separator:aa3ed2d23c2944de6d892d771254fb1f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01717fe28f7d1992f4444dabec4e1d57"><td class="memItemLeft" align="right" valign="top">std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="linearalgebra_8hpp.html#a01717fe28f7d1992f4444dabec4e1d57">operator*</a> (double b, std::vector&lt; double &gt; A)</td></tr>
<tr class="memdesc:a01717fe28f7d1992f4444dabec4e1d57"><td class="mdescLeft">&#160;</td><td class="mdescRight">Operator form of <a class="el" href="linearalgebra_8hpp.html#a9421c6d0ca55335d00acec320e0214b4" title="Vector scalar prodcut of vector and scalar. ">VectorScalarProduct()</a>, using std library forwarding.  <a href="#a01717fe28f7d1992f4444dabec4e1d57">More...</a><br /></td></tr>
<tr class="separator:a01717fe28f7d1992f4444dabec4e1d57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72d0ecda9513107497ecda3d8d8950f5"><td class="memItemLeft" align="right" valign="top">std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="linearalgebra_8hpp.html#a72d0ecda9513107497ecda3d8d8950f5">operator*</a> (std::vector&lt; double &gt; A, double b)</td></tr>
<tr class="memdesc:a72d0ecda9513107497ecda3d8d8950f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Operator form of <a class="el" href="linearalgebra_8hpp.html#a9421c6d0ca55335d00acec320e0214b4" title="Vector scalar prodcut of vector and scalar. ">VectorScalarProduct()</a>, using std library forwarding.  <a href="#a72d0ecda9513107497ecda3d8d8950f5">More...</a><br /></td></tr>
<tr class="separator:a72d0ecda9513107497ecda3d8d8950f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66445bb62c71fb0f100dcac2184cd340"><td class="memItemLeft" align="right" valign="top">std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="linearalgebra_8hpp.html#a66445bb62c71fb0f100dcac2184cd340">operator/</a> (std::vector&lt; double &gt; A, double b)</td></tr>
<tr class="memdesc:a66445bb62c71fb0f100dcac2184cd340"><td class="mdescLeft">&#160;</td><td class="mdescRight">Operator form of vector by scalar division. Uses <a class="el" href="linearalgebra_8hpp.html#a9421c6d0ca55335d00acec320e0214b4" title="Vector scalar prodcut of vector and scalar. ">VectorScalarProduct()</a> with std library forwarding.  <a href="#a66445bb62c71fb0f100dcac2184cd340">More...</a><br /></td></tr>
<tr class="separator:a66445bb62c71fb0f100dcac2184cd340"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a324f0c5e80400318b00be85689f022a2"><td class="memItemLeft" align="right" valign="top">std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="linearalgebra_8hpp.html#a324f0c5e80400318b00be85689f022a2">operator+</a> (std::vector&lt; double &gt; A, std::vector&lt; double &gt; B)</td></tr>
<tr class="memdesc:a324f0c5e80400318b00be85689f022a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Operator form of <a class="el" href="linearalgebra_8hpp.html#a6d9bdc7160e3c8640cf0eaca466985ee" title="Vector sum between two vectors. ">VectorSum()</a>, using std library forwarding.  <a href="#a324f0c5e80400318b00be85689f022a2">More...</a><br /></td></tr>
<tr class="separator:a324f0c5e80400318b00be85689f022a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a136a23033adff2ede8b4f8ddebb4311f"><td class="memItemLeft" align="right" valign="top">std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="linearalgebra_8hpp.html#a136a23033adff2ede8b4f8ddebb4311f">operator-</a> (std::vector&lt; double &gt; A, std::vector&lt; double &gt; B)</td></tr>
<tr class="memdesc:a136a23033adff2ede8b4f8ddebb4311f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Operator form of <a class="el" href="linearalgebra_8hpp.html#a597e4b880c84d3ce0442b6afc04dceaf" title="Vector difference between two vectors. ">VectorDifference()</a>, using std library forwarding.  <a href="#a136a23033adff2ede8b4f8ddebb4311f">More...</a><br /></td></tr>
<tr class="separator:a136a23033adff2ede8b4f8ddebb4311f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42675d143e4235e361a43cdfcf6f4723"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::vector&lt; double &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="linearalgebra_8hpp.html#a42675d143e4235e361a43cdfcf6f4723">operator+</a> (std::vector&lt; std::vector&lt; double &gt;&gt; M, std::vector&lt; std::vector&lt; double &gt;&gt; N)</td></tr>
<tr class="memdesc:a42675d143e4235e361a43cdfcf6f4723"><td class="mdescLeft">&#160;</td><td class="mdescRight">Operator form of <a class="el" href="linearalgebra_8hpp.html#a22e3e11bc1914c1335383c9c22abaf88" title="A function to calculate the sum of the entries of two matrices. ">MatrixMatrixSum()</a>, using std library forwarding.  <a href="#a42675d143e4235e361a43cdfcf6f4723">More...</a><br /></td></tr>
<tr class="separator:a42675d143e4235e361a43cdfcf6f4723"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Linear algebra functions operating on standard library containers. </p>
<p>Lars Gebraad (<a href="#" onclick="location.href='mai'+'lto:'+'lar'+'sg'+'ebr'+'aa'+'d@g'+'ma'+'il.'+'co'+'m'; return false;">larsg<span style="display: none;">.nosp@m.</span>ebra<span style="display: none;">.nosp@m.</span>ad@gm<span style="display: none;">.nosp@m.</span>ail.<span style="display: none;">.nosp@m.</span>com</a>) </p><dl class="section date"><dt>Date</dt><dd>September, 2008 A kind of library for all kinds of linear algebra functions. Incorporates basic operations such as multiplication and dot products (with respective operator overloading) as well as some more specialized functions such as Cholesky decomposition and lower triangular matrix inversion.</dd></dl>
<p>This set of function operate on containers defined in the standard library. Most of the objects passed as input or output within this set of functions are std::vector's, of either std::vector&lt;doubles&gt; or doubles itself. These containers act as vectors and matrices. The benefit of these is that they are memory optimized, allow for (nearly) perfect forwarding and other easy manipulation.</p>
<p>When I refer to matrices or vectors, the actual C++ objects will be these containers (of containers) of doubles. The first elements have index zero.</p>
<p>Note that if there are nested containers, the convention is that the first index (the outer container) represents rows, where the inner containers represent row elements. There is no easy way to directly access a column, except when usen <a class="el" href="linearalgebra_8hpp.html#a127f5797dcb79c36454247e48e4e8c9e" title="Function to get a column from a matrix. ">GetMatrixColumn()</a>. </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="a2747a4af46ad421a36728cf645df6bbc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2747a4af46ad421a36728cf645df6bbc">&#9670;&nbsp;</a></span>CholeskyDecompose()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::vector&lt;double&gt; &gt; CholeskyDecompose </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::vector&lt; double &gt;&gt;&#160;</td>
          <td class="paramname"><em>A</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Cholesky-decomposition of a positive definite Hermitian \( n \times n\) matrix \( M \). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>A positive definite Hermitian \( n \times n\) matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A lower triangular \( n \times n\) matrix for which holds \( L L^\dagger = M \), where \( L^\dagger \) is the adjoint of \( L \) (which of course simplifies to transposition for real matrices). </dd></dl>

</div>
</div>
<a id="a127f5797dcb79c36454247e48e4e8c9e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a127f5797dcb79c36454247e48e4e8c9e">&#9670;&nbsp;</a></span>GetMatrixColumn()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;double&gt; GetMatrixColumn </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::vector&lt; double &gt;&gt;&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>column</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to get a column from a matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">M</td><td>Any \( n \times m \) matrix \(M\). </td></tr>
    <tr><td class="paramname">row</td><td>Integer indicating the column. Numbering starts at 0. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An \( n \) dimensional vector containing the extracted matrix column. </dd></dl>

</div>
</div>
<a id="af4d8fb25b53a9b6ab36eba4314e7874f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4d8fb25b53a9b6ab36eba4314e7874f">&#9670;&nbsp;</a></span>GetMatrixRow()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;double&gt; GetMatrixRow </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::vector&lt; double &gt;&gt;&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>row</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to get a row from a matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">M</td><td>Any \( n \times m \) matrix \(M\). </td></tr>
    <tr><td class="paramname">row</td><td>Integer indicating the row. Numbering starts at 0. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An \( m \) dimensional vector containing the extracted matrix row. </dd></dl>

</div>
</div>
<a id="a7a992c16cae0e72fae2e70a6cd1dab03"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a992c16cae0e72fae2e70a6cd1dab03">&#9670;&nbsp;</a></span>InvertLowerTriangular()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::vector&lt;double&gt; &gt; InvertLowerTriangular </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::vector&lt; double &gt;&gt;&#160;</td>
          <td class="paramname"><em>L</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Invert a lower triangular \( n \times n\) matrix by use of solving the system \( L L^{-1} = I\) per column of \( I \) using <a class="el" href="linearalgebra_8hpp.html#a8407d518eb711c46ddc3e729299fa011" title="Solve linear equation  where  is a lower triangular  matrix and  and  are  dimensional vectors...">SolveLowerTriangular()</a>, the identity matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">L</td><td>Any lower triangular \( n \times n\) matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The inverse of \( L \), another lower triangular \( n \times n\) matrix. </dd></dl>

</div>
</div>
<a id="af6ebca5acd83b99acfd9e48c1cceafb2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6ebca5acd83b99acfd9e48c1cceafb2">&#9670;&nbsp;</a></span>InvertMatrixElements()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::vector&lt;double&gt; &gt; InvertMatrixElements </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::vector&lt; double &gt;&gt;&#160;</td>
          <td class="paramname"><em>M</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to take the inverse of the individual matrix elements. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">M</td><td>Any \( n \times m \) matrix \(M\). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The inverted elements \( 1/M_{ij}\) in a std::vector of std::vector of double. </dd></dl>

</div>
</div>
<a id="ad0972fd0613212a5f363f740fa8da87b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0972fd0613212a5f363f740fa8da87b">&#9670;&nbsp;</a></span>MatrixMatrixProduct()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::vector&lt;double&gt; &gt; MatrixMatrixProduct </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::vector&lt; double &gt;&gt;&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::vector&lt; double &gt;&gt;&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function incorporating the standard matrix-matrix product, producing a new matrix. Matrix M should have as many columns as N has rows, otherwise an exception is thrown. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">M</td><td>Any \( n \times m \) matrix \(M\). </td></tr>
    <tr><td class="paramname">N</td><td>Any \( m \times p \) matrix \(N\). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A \( n \times p \) matrix P defined by \( P_{ij} = \sum_{k=1}^m M_{ik} N_{kj} \). </dd></dl>

</div>
</div>
<a id="a22e3e11bc1914c1335383c9c22abaf88"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22e3e11bc1914c1335383c9c22abaf88">&#9670;&nbsp;</a></span>MatrixMatrixSum()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::vector&lt;double&gt; &gt; MatrixMatrixSum </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::vector&lt; double &gt;&gt;&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::vector&lt; double &gt;&gt;&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A function to calculate the sum of the entries of two matrices. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">M</td><td>Any \( n \times m \) matrix \(M\). </td></tr>
    <tr><td class="paramname">N</td><td>Any \( n \times m \) matrix \(N\). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A \( n \times m \) matrix \( S \) containing the sum of the entries of \(M\) and \(N\). </dd></dl>

</div>
</div>
<a id="a451df8b9bf01cd6a09234161ecf39dd5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a451df8b9bf01cd6a09234161ecf39dd5">&#9670;&nbsp;</a></span>MatrixTrace()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;double&gt; MatrixTrace </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::vector&lt; double &gt;&gt;&#160;</td>
          <td class="paramname"><em>M</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to the trace of a square \(n \times n\) matrix \(M\). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">M</td><td>Any square matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The trace of \( M \). </dd></dl>

</div>
</div>
<a id="a2c0f436b85983ff2f83d8baca22e76e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c0f436b85983ff2f83d8baca22e76e8">&#9670;&nbsp;</a></span>MatrixVectorProduct()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;double&gt; MatrixVectorProduct </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::vector&lt; double &gt;&gt;&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; double &gt;&#160;</td>
          <td class="paramname"><em>A</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function incorporating the standard matrix-vector product. The result is a column vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">M</td><td>Any \( n \times m \) matrix \(M\). </td></tr>
    <tr><td class="paramname">A</td><td>Any \( m \) dimensional vector A. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A \( n \) dimensional vector B which is defined through: \( B_i = \sum_{k=1}^m M_{ik} A_k \). </dd></dl>

</div>
</div>
<a id="a4267f1b16fd7b2f26ec7505f6e978b9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4267f1b16fd7b2f26ec7505f6e978b9f">&#9670;&nbsp;</a></span>NormalizeVector()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;double&gt; NormalizeVector </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; double &gt;&#160;</td>
          <td class="paramname"><em>A</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Normalizes a vector to unit length. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>Any vector \( A \). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Vector \( B&#39; \) where \( \sqrt{\sum_i {B_{i}}^{2} }= 1\) and \( A \cdot B = |A| |B| = |A|\) . </dd></dl>

</div>
</div>
<a id="a1d49ea659488ef4b766b63011282bf5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d49ea659488ef4b766b63011282bf5f">&#9670;&nbsp;</a></span>operator*() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::vector&lt;double&gt; &gt; operator* </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::vector&lt; double &gt;&gt;&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::vector&lt; double &gt;&gt;&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Operator form of <a class="el" href="linearalgebra_8hpp.html#ad0972fd0613212a5f363f740fa8da87b" title="Function incorporating the standard matrix-matrix product, producing a new matrix. Matrix M should have as many columns as N has rows, otherwise an exception is thrown. ">MatrixMatrixProduct()</a>, using std library forwarding. </p>

</div>
</div>
<a id="a66df0c52ac36dd31ea31fb18ffbfeeb8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66df0c52ac36dd31ea31fb18ffbfeeb8">&#9670;&nbsp;</a></span>operator*() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double operator* </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; double &gt;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; double &gt;&#160;</td>
          <td class="paramname"><em>B</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Operator form of <a class="el" href="linearalgebra_8hpp.html#a3815a35abdfaafef440a2bbb8c62a58f" title="Dot product of vectors. ">VectorVectorProduct()</a>, using std library forwarding. </p>

</div>
</div>
<a id="aa3ed2d23c2944de6d892d771254fb1f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3ed2d23c2944de6d892d771254fb1f1">&#9670;&nbsp;</a></span>operator*() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;double&gt; operator* </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::vector&lt; double &gt;&gt;&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; double &gt;&#160;</td>
          <td class="paramname"><em>A</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Operator form of <a class="el" href="linearalgebra_8hpp.html#a2c0f436b85983ff2f83d8baca22e76e8" title="Function incorporating the standard matrix-vector product. The result is a column vector...">MatrixVectorProduct()</a>, using std library forwarding. </p>

</div>
</div>
<a id="a01717fe28f7d1992f4444dabec4e1d57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01717fe28f7d1992f4444dabec4e1d57">&#9670;&nbsp;</a></span>operator*() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;double&gt; operator* </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; double &gt;&#160;</td>
          <td class="paramname"><em>A</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Operator form of <a class="el" href="linearalgebra_8hpp.html#a9421c6d0ca55335d00acec320e0214b4" title="Vector scalar prodcut of vector and scalar. ">VectorScalarProduct()</a>, using std library forwarding. </p>

</div>
</div>
<a id="a72d0ecda9513107497ecda3d8d8950f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72d0ecda9513107497ecda3d8d8950f5">&#9670;&nbsp;</a></span>operator*() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;double&gt; operator* </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; double &gt;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Operator form of <a class="el" href="linearalgebra_8hpp.html#a9421c6d0ca55335d00acec320e0214b4" title="Vector scalar prodcut of vector and scalar. ">VectorScalarProduct()</a>, using std library forwarding. </p>

</div>
</div>
<a id="a324f0c5e80400318b00be85689f022a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a324f0c5e80400318b00be85689f022a2">&#9670;&nbsp;</a></span>operator+() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;double&gt; operator+ </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; double &gt;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; double &gt;&#160;</td>
          <td class="paramname"><em>B</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Operator form of <a class="el" href="linearalgebra_8hpp.html#a6d9bdc7160e3c8640cf0eaca466985ee" title="Vector sum between two vectors. ">VectorSum()</a>, using std library forwarding. </p>

</div>
</div>
<a id="a42675d143e4235e361a43cdfcf6f4723"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42675d143e4235e361a43cdfcf6f4723">&#9670;&nbsp;</a></span>operator+() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::vector&lt;double&gt; &gt; operator+ </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::vector&lt; double &gt;&gt;&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::vector&lt; double &gt;&gt;&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Operator form of <a class="el" href="linearalgebra_8hpp.html#a22e3e11bc1914c1335383c9c22abaf88" title="A function to calculate the sum of the entries of two matrices. ">MatrixMatrixSum()</a>, using std library forwarding. </p>

</div>
</div>
<a id="a136a23033adff2ede8b4f8ddebb4311f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a136a23033adff2ede8b4f8ddebb4311f">&#9670;&nbsp;</a></span>operator-()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;double&gt; operator- </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; double &gt;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; double &gt;&#160;</td>
          <td class="paramname"><em>B</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Operator form of <a class="el" href="linearalgebra_8hpp.html#a597e4b880c84d3ce0442b6afc04dceaf" title="Vector difference between two vectors. ">VectorDifference()</a>, using std library forwarding. </p>

</div>
</div>
<a id="a66445bb62c71fb0f100dcac2184cd340"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66445bb62c71fb0f100dcac2184cd340">&#9670;&nbsp;</a></span>operator/()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;double&gt; operator/ </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; double &gt;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Operator form of vector by scalar division. Uses <a class="el" href="linearalgebra_8hpp.html#a9421c6d0ca55335d00acec320e0214b4" title="Vector scalar prodcut of vector and scalar. ">VectorScalarProduct()</a> with std library forwarding. </p>

</div>
</div>
<a id="a8407d518eb711c46ddc3e729299fa011"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8407d518eb711c46ddc3e729299fa011">&#9670;&nbsp;</a></span>SolveLowerTriangular()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;double&gt; SolveLowerTriangular </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::vector&lt; double &gt;&gt;&#160;</td>
          <td class="paramname"><em>L</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; double &gt;&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Solve linear equation \( L y = x\) where \( L \) is a lower triangular \( n \times n\) matrix and \( x \) and \( y \) are \( n\) dimensional vectors. Uses forward and backward substitution to iteratively solve the system. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">L</td><td>Any lower triangular \( n \times n\) matrix. </td></tr>
    <tr><td class="paramname">x</td><td>Any \( n\) dimensional vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Solution y of the system, an \( n\) dimensional vector. </dd></dl>

</div>
</div>
<a id="a4a31c1bd455fa18e0127d3a8160ddf98"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a31c1bd455fa18e0127d3a8160ddf98">&#9670;&nbsp;</a></span>TransposeMatrix()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::vector&lt;double&gt; &gt; TransposeMatrix </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::vector&lt; double &gt;&gt;&#160;</td>
          <td class="paramname"><em>M</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to transpose a matrix M of size i x j into a matrix N of size j x i, where \(M_{ij} = N_{ji}\). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">M</td><td>Any \( n \times m \) matrix \(M\). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The transpose of \(M\). </dd></dl>

</div>
</div>
<a id="a597e4b880c84d3ce0442b6afc04dceaf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a597e4b880c84d3ce0442b6afc04dceaf">&#9670;&nbsp;</a></span>VectorDifference()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;double&gt; VectorDifference </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; double &gt;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; double &gt;&#160;</td>
          <td class="paramname"><em>B</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Vector difference between two vectors. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>Vector \( A \) of dimension \( n\). </td></tr>
    <tr><td class="paramname">B</td><td>Vector \( B \) of dimension \( n\). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Vector \( C \) where \( C_i = A_i - B_i \). </dd></dl>

</div>
</div>
<a id="a9421c6d0ca55335d00acec320e0214b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9421c6d0ca55335d00acec320e0214b4">&#9670;&nbsp;</a></span>VectorScalarProduct()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;double&gt; VectorScalarProduct </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; double &gt;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Vector scalar prodcut of vector and scalar. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>Any vector \( A \). </td></tr>
    <tr><td class="paramname">B</td><td>Scalar \( b \). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Vector \( C \) where \( C_{i} = A_{i} \cdot b \). </dd></dl>

</div>
</div>
<a id="a6d9bdc7160e3c8640cf0eaca466985ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d9bdc7160e3c8640cf0eaca466985ee">&#9670;&nbsp;</a></span>VectorSum()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;double&gt; VectorSum </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; double &gt;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; double &gt;&#160;</td>
          <td class="paramname"><em>B</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Vector sum between two vectors. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>Vector \( A \) of dimension \( n\). </td></tr>
    <tr><td class="paramname">B</td><td>Vector \( B \) of dimension \( n\). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Vector \( C \) where \( C_i = A_{i} + B_i \). </dd></dl>

</div>
</div>
<a id="ab572e4af238b6622d11655a0704cb918"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab572e4af238b6622d11655a0704cb918">&#9670;&nbsp;</a></span>VectorToDiagonal()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::vector&lt;double&gt; &gt; VectorToDiagonal </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; double &gt;&#160;</td>
          <td class="paramname"><em>A</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function which takes a std::vector of double to make a diagonal matrix of it, such that \( A_{i} = M_{ii} \). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>Any Any \( n \) dimensional vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Diagonal \( n \times n \) matrix \(M\). </dd></dl>

</div>
</div>
<a id="a3815a35abdfaafef440a2bbb8c62a58f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3815a35abdfaafef440a2bbb8c62a58f">&#9670;&nbsp;</a></span>VectorVectorProduct()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double VectorVectorProduct </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; double &gt;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; double &gt;&#160;</td>
          <td class="paramname"><em>B</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Dot product of vectors. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>Vector \( A \) of dimension \( n\). </td></tr>
    <tr><td class="paramname">B</td><td>Vector \( B \) of dimension \( n\). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Dot product \( c \) of \( A \) and \( B \) where where \( c = A_i \cdot B_i \) (float). </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.8-->
<!-- start footer part -->
</div>
</div>
</div>
</div>
</div>
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
